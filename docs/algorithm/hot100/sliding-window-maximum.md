# 11. 滑动窗口最大值
> 题目链接：https://leetcode.cn/problems/sliding-window-maximum

### 解题思路

经典滑动窗口题目，个人觉得难点在于边界控制。

举例：nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3

| **步骤 (i)** | **元素 nums[i]** | **队列操作 (存储的是下标)** | **队列状态 (对应数值)** | **窗口左界 (l)** | **结果 ans[l]** | **说明**                             |
| ------------ | ---------------- | --------------------------- | ----------------------- | ---------------- | --------------- | ------------------------------------ |
| **0**        | **1**            | 加 0                        | `[0]` (1)               | -2               | -               | 1 入队                               |
| **1**        | **3**            | 0 出, 加 1                  | `[1]` (3)               | -1               | -               | 3 比 1 大，1 永远没机会了，剔除      |
| **2**        | **-1**           | 加 2                        | `[1, 2]` (3, -1)        | **0**            | **3**           | 第一个窗口完成，最大值是队头 3       |
| **3**        | **-3**           | 加 3                        | `[1, 2, 3]` (3, -1, -3) | **1**            | **3**           | 队头下标 1 在窗口内，最大值仍是 3    |
| **4**        | **5**            | 1,2,3 出, 加 4              | `[4]` (5)               | **2**            | **5**           | 5 进场，前面所有人都被踢出；1 已过期 |
| **5**        | **3**            | 加 5                        | `[4, 5]` (5, 3)         | **3**            | **5**           | 3 入队，最大值是队头 5               |
| **6**        | **6**            | 4,5 出, 加 6                | `[6]` (6)               | **4**            | **6**           | 6 进场，5 和 3 被踢出                |
| **7**        | **7**            | 6 出, 加 7                  | `[7]` (7)               | **5**            | **7**           | 7 进场，6 被踢出                     |



### java版本解答

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        Deque<Integer> q = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            int l = i - k + 1;
            if (!q.isEmpty() && q.getFirst() < l)q.removeFirst(); // 1. 先删老的
            while (!q.isEmpty() && nums[q.getLast()] <= nums[i])q.removeLast(); // 2. 再踢弱的
            q.addLast(i); // 3. 最后加新的
            if (l >= 0)ans[l] = nums[q.getFirst()]; // 4. 出结果
        }
        return ans;
    }
}
```
